{"ast":null,"code":"// import React from \"react\";\n// import { Stage, Layer, Line, Text } from \"react-konva\";\n\n// export default function LayoutCanvas({ layout }) {\n//   const width = 600, height = 450;\n\n//   // Filter out rooms with less than 3 points (invalid polygons)\n//   const validRooms = layout.filter(room => room.points.length >= 3);\n\n//   // Compute scaling and centering\n//   const allPoints = validRooms.flatMap(room => room.points);\n//   if (allPoints.length === 0) {\n//     // Nothing to render\n//     return (\n//       <div className=\"text-gray-400 text-lg\">\n//         No valid rooms to display.\n//       </div>\n//     );\n//   }\n//   const xs = allPoints.map(p => p[0]);\n//   const ys = allPoints.map(p => p[1]);\n//   const minX = Math.min(...xs), maxX = Math.max(...xs);\n//   const minY = Math.min(...ys), maxY = Math.max(...ys);\n\n//   // Calculate scale to fit the canvas with some margin\n//   const margin = 40;\n//   const scale = Math.min(\n//     (width - margin * 2) / (maxX - minX || 1),\n//     (height - margin * 2) / (maxY - minY || 1)\n//   );\n//   const offsetX = margin - minX * scale + (width - (maxX - minX) * scale) / 2 - margin;\n//   const offsetY = margin - minY * scale + (height - (maxY - minY) * scale) / 2 - margin;\n\n//   // Helper to get centroid for label placement\n//   const getCentroid = (points) => {\n//     const n = points.length;\n//     const sum = points.reduce(\n//       (acc, [x, y]) => [acc[0] + x, acc[1] + y],\n//       [0, 0]\n//     );\n//     return [sum[0] / n, sum[1] / n];\n//   };\n\n//   return (\n//     <Stage width={width} height={height}>\n//       <Layer>\n//         {validRooms.map((room, idx) => {\n//           // Scale and center points\n//           const scaledPoints = room.points.flatMap(([x, y]) => [\n//             x * scale + offsetX,\n//             y * scale + offsetY,\n//           ]);\n//           // Centroid for label\n//           const [cx, cy] = getCentroid(\n//             room.points.map(([x, y]) => [\n//               x * scale + offsetX,\n//               y * scale + offsetY,\n//             ])\n//           );\n//           return (\n//             <React.Fragment key={room.name + idx}>\n//               <Line\n//                 points={scaledPoints}\n//                 closed\n//                 fill=\"#e0e7ff\"\n//                 stroke=\"#1e293b\"\n//                 strokeWidth={2}\n//               />\n//               <Text\n//                 text={room.name}\n//                 x={cx - room.name.length * 4}\n//                 y={cy - 8}\n//                 fontSize={16}\n//                 fill=\"#1e293b\"\n//                 fontStyle=\"bold\"\n//               />\n//             </React.Fragment>\n//           );\n//         })}\n//       </Layer>\n//     </Stage>\n//   );\n// }","map":{"version":3,"names":[],"sources":["C:/Users/LENOVO/Desktop/INFRAMINDS/ChatBot/frontend/src/LayoutCanvas.jsx"],"sourcesContent":["// import React from \"react\";\r\n// import { Stage, Layer, Line, Text } from \"react-konva\";\r\n\r\n// export default function LayoutCanvas({ layout }) {\r\n//   const width = 600, height = 450;\r\n\r\n//   // Filter out rooms with less than 3 points (invalid polygons)\r\n//   const validRooms = layout.filter(room => room.points.length >= 3);\r\n\r\n//   // Compute scaling and centering\r\n//   const allPoints = validRooms.flatMap(room => room.points);\r\n//   if (allPoints.length === 0) {\r\n//     // Nothing to render\r\n//     return (\r\n//       <div className=\"text-gray-400 text-lg\">\r\n//         No valid rooms to display.\r\n//       </div>\r\n//     );\r\n//   }\r\n//   const xs = allPoints.map(p => p[0]);\r\n//   const ys = allPoints.map(p => p[1]);\r\n//   const minX = Math.min(...xs), maxX = Math.max(...xs);\r\n//   const minY = Math.min(...ys), maxY = Math.max(...ys);\r\n\r\n//   // Calculate scale to fit the canvas with some margin\r\n//   const margin = 40;\r\n//   const scale = Math.min(\r\n//     (width - margin * 2) / (maxX - minX || 1),\r\n//     (height - margin * 2) / (maxY - minY || 1)\r\n//   );\r\n//   const offsetX = margin - minX * scale + (width - (maxX - minX) * scale) / 2 - margin;\r\n//   const offsetY = margin - minY * scale + (height - (maxY - minY) * scale) / 2 - margin;\r\n\r\n//   // Helper to get centroid for label placement\r\n//   const getCentroid = (points) => {\r\n//     const n = points.length;\r\n//     const sum = points.reduce(\r\n//       (acc, [x, y]) => [acc[0] + x, acc[1] + y],\r\n//       [0, 0]\r\n//     );\r\n//     return [sum[0] / n, sum[1] / n];\r\n//   };\r\n\r\n//   return (\r\n//     <Stage width={width} height={height}>\r\n//       <Layer>\r\n//         {validRooms.map((room, idx) => {\r\n//           // Scale and center points\r\n//           const scaledPoints = room.points.flatMap(([x, y]) => [\r\n//             x * scale + offsetX,\r\n//             y * scale + offsetY,\r\n//           ]);\r\n//           // Centroid for label\r\n//           const [cx, cy] = getCentroid(\r\n//             room.points.map(([x, y]) => [\r\n//               x * scale + offsetX,\r\n//               y * scale + offsetY,\r\n//             ])\r\n//           );\r\n//           return (\r\n//             <React.Fragment key={room.name + idx}>\r\n//               <Line\r\n//                 points={scaledPoints}\r\n//                 closed\r\n//                 fill=\"#e0e7ff\"\r\n//                 stroke=\"#1e293b\"\r\n//                 strokeWidth={2}\r\n//               />\r\n//               <Text\r\n//                 text={room.name}\r\n//                 x={cx - room.name.length * 4}\r\n//                 y={cy - 8}\r\n//                 fontSize={16}\r\n//                 fill=\"#1e293b\"\r\n//                 fontStyle=\"bold\"\r\n//               />\r\n//             </React.Fragment>\r\n//           );\r\n//         })}\r\n//       </Layer>\r\n//     </Stage>\r\n//   );\r\n// }\r\n\r\n\r\n"],"mappings":"AAAA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}