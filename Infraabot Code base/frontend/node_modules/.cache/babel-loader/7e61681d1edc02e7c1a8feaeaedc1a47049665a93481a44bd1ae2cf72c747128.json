{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\LENOVO\\\\Desktop\\\\INFRAMINDS\\\\ChatBot\\\\frontend\\\\src\\\\LayoutCanvas.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { Stage, Layer, Line, Text, Group, Rect, Transformer } from \"react-konva\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function LayoutCanvas({\n  layout,\n  onUpdateRoom,\n  selectedRoom,\n  onSelectRoom,\n  onDeleteRoom,\n  plotDimensions = {\n    width: 1000,\n    height: 800\n  } // Default plot area\n}) {\n  _s();\n  const width = 600,\n    height = 450;\n  const shapeRefs = useRef([]);\n  const trRef = useRef();\n\n  // Local state for hover\n  const [hoveredIdx, setHoveredIdx] = useState(null);\n\n  // Attach transformer to the selected room\n  useEffect(() => {\n    if (trRef.current && selectedRoom !== null && shapeRefs.current[selectedRoom]) {\n      trRef.current.nodes([shapeRefs.current[selectedRoom]]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [selectedRoom, layout]);\n\n  // Filter out rooms with less than 3 points (invalid polygons)\n  const validRooms = layout.filter(room => room.points.length >= 3);\n\n  // --- Center and scale layout inside the plot area ---\n  // 1. Find bounding box of all rooms\n  const allPoints = validRooms.flatMap(room => room.points);\n  const xs = allPoints.map(([x, y]) => x);\n  const ys = allPoints.map(([x, y]) => y);\n  const minX = Math.min(...xs),\n    maxX = Math.max(...xs);\n  const minY = Math.min(...ys),\n    maxY = Math.max(...ys);\n\n  // 2. Compute layout bounding box size\n  const layoutWidth = maxX - minX;\n  const layoutHeight = maxY - minY;\n\n  // 3. Plot size\n  const plotWidth = plotDimensions.width;\n  const plotHeight = plotDimensions.height;\n\n  // 4. Compute scale to fit layout in plot (proportionally)\n  const layoutToPlotScale = Math.min(plotWidth / (layoutWidth || 1), plotHeight / (layoutHeight || 1));\n\n  // 5. Compute offset to center layout in plot\n  const layoutOffsetX = (plotWidth - layoutWidth * layoutToPlotScale) / 2 - minX * layoutToPlotScale;\n  const layoutOffsetY = (plotHeight - layoutHeight * layoutToPlotScale) / 2 - minY * layoutToPlotScale;\n\n  // --- Now scale/center the plot area itself into the canvas ---\n  const margin = 40;\n  const scale = Math.min((width - margin * 2) / plotWidth, (height - margin * 2) / plotHeight);\n  const offsetX = margin + (width - plotWidth * scale) / 2;\n  const offsetY = margin + (height - plotHeight * scale) / 2;\n\n  // Helper to get centroid for label placement (in canvas space)\n  const getCentroid = points => {\n    const n = points.length;\n    const sum = points.reduce((acc, [x, y]) => [acc[0] + x, acc[1] + y], [0, 0]);\n    return [sum[0] / n, sum[1] / n];\n  };\n\n  // Handle drag end: update room coordinates and constrain to plot area\n  const handleDragEnd = (idx, e) => {\n    const node = e.target;\n    // Undo both scales to get real plot-space delta\n    const dx = node.x() / (scale * layoutToPlotScale);\n    const dy = node.y() / (scale * layoutToPlotScale);\n    const currentPoints = layout[idx].points;\n    let minXr = Infinity,\n      minYr = Infinity,\n      maxXr = -Infinity,\n      maxYr = -Infinity;\n    currentPoints.forEach(([x, y]) => {\n      minXr = Math.min(minXr, x);\n      minYr = Math.min(minYr, y);\n      maxXr = Math.max(maxXr, x);\n      maxYr = Math.max(maxYr, y);\n    });\n\n    // Proposed new bounding box\n    let allowedDx = dx,\n      allowedDy = dy;\n    if ((minXr + dx) * layoutToPlotScale < 0) allowedDx = -minXr;\n    if ((maxXr + dx) * layoutToPlotScale > plotWidth) allowedDx = plotWidth / layoutToPlotScale - maxXr;\n    if ((minYr + dy) * layoutToPlotScale < 0) allowedDy = -minYr;\n    if ((maxYr + dy) * layoutToPlotScale > plotHeight) allowedDy = plotHeight / layoutToPlotScale - maxYr;\n    const newPoints = currentPoints.map(([x, y]) => [x + allowedDx, y + allowedDy]);\n    node.position({\n      x: 0,\n      y: 0\n    });\n    if (onUpdateRoom) {\n      onUpdateRoom(idx, {\n        ...layout[idx],\n        points: newPoints\n      });\n    }\n  };\n\n  // Handle resize for rectangles (4-point polygons)\n  const handleTransformEnd = idx => {\n    const shape = shapeRefs.current[idx];\n    if (!shape) return;\n\n    // Get the scale applied by the transformer (in canvas space)\n    const scaleX = shape.scaleX();\n    const scaleY = shape.scaleY();\n\n    // Get the original points (before scaling)\n    const points = layout[idx].points;\n    const [x0, y0] = points[0];\n    const [x1, y1] = points[1];\n    const [x2, y2] = points[2];\n    const [x3, y3] = points[3];\n\n    // Compute width and height from the original points\n    const width0 = Math.abs(x1 - x0);\n    const height0 = Math.abs(y3 - y0);\n\n    // Apply scale to width and height\n    let newWidth = width0 * scaleX;\n    let newHeight = height0 * scaleY;\n\n    // Constrain resizing to plot area\n    let maxWidth = plotWidth / layoutToPlotScale - x0;\n    let maxHeight = plotHeight / layoutToPlotScale - y0;\n    newWidth = Math.max(10 / layoutToPlotScale, Math.min(newWidth, maxWidth));\n    newHeight = Math.max(10 / layoutToPlotScale, Math.min(newHeight, maxHeight));\n\n    // Calculate new points for the rectangle\n    const newPoints = [[x0, y0], [x0 + newWidth, y0], [x0 + newWidth, y0 + newHeight], [x0, y0 + newHeight]];\n\n    // Reset the scale to 1\n    shape.scaleX(1);\n    shape.scaleY(1);\n    onUpdateRoom(idx, {\n      ...layout[idx],\n      points: newPoints\n    });\n  };\n  if (validRooms.length === 0) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"text-gray-400 text-lg\",\n      children: \"No valid rooms to display.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 155,\n      columnNumber: 7\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(Stage, {\n    width: width,\n    height: height,\n    children: /*#__PURE__*/_jsxDEV(Layer, {\n      children: [/*#__PURE__*/_jsxDEV(Rect, {\n        x: offsetX,\n        y: offsetY,\n        width: plotWidth * scale,\n        height: plotHeight * scale,\n        stroke: \"#000\",\n        strokeWidth: 2,\n        fill: \"transparent\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 9\n      }, this), validRooms.map((room, idx) => {\n        // First, scale and center layout in plot space, then map plot to canvas\n        const scaledPoints = room.points.flatMap(([x, y]) => [(x * layoutToPlotScale + layoutOffsetX) * scale + offsetX, (y * layoutToPlotScale + layoutOffsetY) * scale + offsetY]);\n        // Centroid for label\n        const [cx, cy] = getCentroid(room.points.map(([x, y]) => [(x * layoutToPlotScale + layoutOffsetX) * scale + offsetX, (y * layoutToPlotScale + layoutOffsetY) * scale + offsetY]));\n        const isSelected = selectedRoom === idx;\n        const isHovered = hoveredIdx === idx;\n\n        // Find top-right corner for delete icon\n        const xs = scaledPoints.filter((_, i) => i % 2 === 0);\n        const ys = scaledPoints.filter((_, i) => i % 2 === 1);\n        const topRightX = Math.max(...xs);\n        const topRightY = Math.min(...ys);\n        return /*#__PURE__*/_jsxDEV(Group, {\n          draggable: true,\n          onDragEnd: e => handleDragEnd(idx, e),\n          onMouseEnter: () => setHoveredIdx(idx),\n          onMouseLeave: () => setHoveredIdx(null),\n          onClick: () => onSelectRoom(idx),\n          onTap: () => onSelectRoom(idx),\n          children: [/*#__PURE__*/_jsxDEV(Line, {\n            ref: node => shapeRefs.current[idx] = node,\n            points: scaledPoints,\n            closed: true,\n            fill: \"#e0e7ff\",\n            stroke: isSelected ? \"#f59e42\" : isHovered ? \"#2563eb\" : \"#1e293b\",\n            strokeWidth: isSelected ? 4 : isHovered ? 3 : 2,\n            shadowBlur: isSelected ? 8 : 0\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 207,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(Text, {\n            text: room.name,\n            x: cx,\n            y: cy,\n            fontSize: 16,\n            fill: \"#1e293b\",\n            fontStyle: \"bold\",\n            align: \"center\",\n            verticalAlign: \"middle\",\n            offsetX: room.name.length * 8,\n            offsetY: 8\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 218,\n            columnNumber: 15\n          }, this), isSelected && onDeleteRoom && /*#__PURE__*/_jsxDEV(_Fragment, {\n            children: [/*#__PURE__*/_jsxDEV(Rect, {\n              x: topRightX - 10,\n              y: topRightY - 10,\n              width: 20,\n              height: 20,\n              fill: \"#f87171\",\n              cornerRadius: 4,\n              onClick: () => onDeleteRoom(idx),\n              onTap: () => onDeleteRoom(idx),\n              style: {\n                cursor: \"pointer\"\n              }\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 234,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(Text, {\n              text: \"\\uD83D\\uDDD1\",\n              x: topRightX - 6,\n              y: topRightY - 10,\n              fontSize: 16,\n              onClick: () => onDeleteRoom(idx),\n              onTap: () => onDeleteRoom(idx),\n              style: {\n                cursor: \"pointer\"\n              }\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 245,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true), isSelected && room.points.length === 4 && /*#__PURE__*/_jsxDEV(Transformer, {\n            ref: trRef,\n            boundBoxFunc: (oldBox, newBox) => newBox,\n            onTransformEnd: () => handleTransformEnd(idx),\n            rotateEnabled: false,\n            enabledAnchors: [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 258,\n            columnNumber: 17\n          }, this)]\n        }, room.name + idx, true, {\n          fileName: _jsxFileName,\n          lineNumber: 198,\n          columnNumber: 13\n        }, this);\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 163,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 162,\n    columnNumber: 5\n  }, this);\n}\n_s(LayoutCanvas, \"5czcpnImJiA7JzMoNwVkAcOjREg=\");\n_c = LayoutCanvas;\nvar _c;\n$RefreshReg$(_c, \"LayoutCanvas\");","map":{"version":3,"names":["React","useState","useRef","useEffect","Stage","Layer","Line","Text","Group","Rect","Transformer","jsxDEV","_jsxDEV","Fragment","_Fragment","LayoutCanvas","layout","onUpdateRoom","selectedRoom","onSelectRoom","onDeleteRoom","plotDimensions","width","height","_s","shapeRefs","trRef","hoveredIdx","setHoveredIdx","current","nodes","getLayer","batchDraw","validRooms","filter","room","points","length","allPoints","flatMap","xs","map","x","y","ys","minX","Math","min","maxX","max","minY","maxY","layoutWidth","layoutHeight","plotWidth","plotHeight","layoutToPlotScale","layoutOffsetX","layoutOffsetY","margin","scale","offsetX","offsetY","getCentroid","n","sum","reduce","acc","handleDragEnd","idx","e","node","target","dx","dy","currentPoints","minXr","Infinity","minYr","maxXr","maxYr","forEach","allowedDx","allowedDy","newPoints","position","handleTransformEnd","shape","scaleX","scaleY","x0","y0","x1","y1","x2","y2","x3","y3","width0","abs","height0","newWidth","newHeight","maxWidth","maxHeight","className","children","fileName","_jsxFileName","lineNumber","columnNumber","stroke","strokeWidth","fill","scaledPoints","cx","cy","isSelected","isHovered","_","i","topRightX","topRightY","draggable","onDragEnd","onMouseEnter","onMouseLeave","onClick","onTap","ref","closed","shadowBlur","text","name","fontSize","fontStyle","align","verticalAlign","cornerRadius","style","cursor","boundBoxFunc","oldBox","newBox","onTransformEnd","rotateEnabled","enabledAnchors","_c","$RefreshReg$"],"sources":["C:/Users/LENOVO/Desktop/INFRAMINDS/ChatBot/frontend/src/LayoutCanvas.jsx"],"sourcesContent":["import React, { useState, useRef, useEffect } from \"react\";\r\nimport { Stage, Layer, Line, Text, Group, Rect, Transformer } from \"react-konva\";\r\n\r\nexport default function LayoutCanvas({\r\n  layout,\r\n  onUpdateRoom,\r\n  selectedRoom,\r\n  onSelectRoom,\r\n  onDeleteRoom,\r\n  plotDimensions = { width: 1000, height: 800 }, // Default plot area\r\n}) {\r\n  const width = 600, height = 450;\r\n  const shapeRefs = useRef([]);\r\n  const trRef = useRef();\r\n\r\n  // Local state for hover\r\n  const [hoveredIdx, setHoveredIdx] = useState(null);\r\n\r\n  // Attach transformer to the selected room\r\n  useEffect(() => {\r\n    if (trRef.current && selectedRoom !== null && shapeRefs.current[selectedRoom]) {\r\n      trRef.current.nodes([shapeRefs.current[selectedRoom]]);\r\n      trRef.current.getLayer().batchDraw();\r\n    }\r\n  }, [selectedRoom, layout]);\r\n\r\n  // Filter out rooms with less than 3 points (invalid polygons)\r\n  const validRooms = layout.filter(room => room.points.length >= 3);\r\n\r\n  // --- Center and scale layout inside the plot area ---\r\n  // 1. Find bounding box of all rooms\r\n  const allPoints = validRooms.flatMap(room => room.points);\r\n  const xs = allPoints.map(([x, y]) => x);\r\n  const ys = allPoints.map(([x, y]) => y);\r\n  const minX = Math.min(...xs), maxX = Math.max(...xs);\r\n  const minY = Math.min(...ys), maxY = Math.max(...ys);\r\n\r\n  // 2. Compute layout bounding box size\r\n  const layoutWidth = maxX - minX;\r\n  const layoutHeight = maxY - minY;\r\n\r\n  // 3. Plot size\r\n  const plotWidth = plotDimensions.width;\r\n  const plotHeight = plotDimensions.height;\r\n\r\n  // 4. Compute scale to fit layout in plot (proportionally)\r\n  const layoutToPlotScale = Math.min(\r\n    plotWidth / (layoutWidth || 1),\r\n    plotHeight / (layoutHeight || 1)\r\n  );\r\n\r\n  // 5. Compute offset to center layout in plot\r\n  const layoutOffsetX = (plotWidth - layoutWidth * layoutToPlotScale) / 2 - minX * layoutToPlotScale;\r\n  const layoutOffsetY = (plotHeight - layoutHeight * layoutToPlotScale) / 2 - minY * layoutToPlotScale;\r\n\r\n  // --- Now scale/center the plot area itself into the canvas ---\r\n  const margin = 40;\r\n  const scale = Math.min(\r\n    (width - margin * 2) / plotWidth,\r\n    (height - margin * 2) / plotHeight\r\n  );\r\n  const offsetX = margin + (width - plotWidth * scale) / 2;\r\n  const offsetY = margin + (height - plotHeight * scale) / 2;\r\n\r\n  // Helper to get centroid for label placement (in canvas space)\r\n  const getCentroid = (points) => {\r\n    const n = points.length;\r\n    const sum = points.reduce(\r\n      (acc, [x, y]) => [acc[0] + x, acc[1] + y],\r\n      [0, 0]\r\n    );\r\n    return [sum[0] / n, sum[1] / n];\r\n  };\r\n\r\n  // Handle drag end: update room coordinates and constrain to plot area\r\n  const handleDragEnd = (idx, e) => {\r\n    const node = e.target;\r\n    // Undo both scales to get real plot-space delta\r\n    const dx = node.x() / (scale * layoutToPlotScale);\r\n    const dy = node.y() / (scale * layoutToPlotScale);\r\n\r\n    const currentPoints = layout[idx].points;\r\n    let minXr = Infinity, minYr = Infinity, maxXr = -Infinity, maxYr = -Infinity;\r\n    currentPoints.forEach(([x, y]) => {\r\n      minXr = Math.min(minXr, x);\r\n      minYr = Math.min(minYr, y);\r\n      maxXr = Math.max(maxXr, x);\r\n      maxYr = Math.max(maxYr, y);\r\n    });\r\n\r\n    // Proposed new bounding box\r\n    let allowedDx = dx, allowedDy = dy;\r\n    if ((minXr + dx) * layoutToPlotScale < 0) allowedDx = -minXr;\r\n    if ((maxXr + dx) * layoutToPlotScale > plotWidth) allowedDx = (plotWidth / layoutToPlotScale) - maxXr;\r\n    if ((minYr + dy) * layoutToPlotScale < 0) allowedDy = -minYr;\r\n    if ((maxYr + dy) * layoutToPlotScale > plotHeight) allowedDy = (plotHeight / layoutToPlotScale) - maxYr;\r\n\r\n    const newPoints = currentPoints.map(([x, y]) => [\r\n      x + allowedDx,\r\n      y + allowedDy,\r\n    ]);\r\n    node.position({ x: 0, y: 0 });\r\n    if (onUpdateRoom) {\r\n      onUpdateRoom(idx, { ...layout[idx], points: newPoints });\r\n    }\r\n  };\r\n\r\n  // Handle resize for rectangles (4-point polygons)\r\n  const handleTransformEnd = (idx) => {\r\n    const shape = shapeRefs.current[idx];\r\n    if (!shape) return;\r\n\r\n    // Get the scale applied by the transformer (in canvas space)\r\n    const scaleX = shape.scaleX();\r\n    const scaleY = shape.scaleY();\r\n\r\n    // Get the original points (before scaling)\r\n    const points = layout[idx].points;\r\n    const [x0, y0] = points[0];\r\n    const [x1, y1] = points[1];\r\n    const [x2, y2] = points[2];\r\n    const [x3, y3] = points[3];\r\n\r\n    // Compute width and height from the original points\r\n    const width0 = Math.abs(x1 - x0);\r\n    const height0 = Math.abs(y3 - y0);\r\n\r\n    // Apply scale to width and height\r\n    let newWidth = width0 * scaleX;\r\n    let newHeight = height0 * scaleY;\r\n\r\n    // Constrain resizing to plot area\r\n    let maxWidth = plotWidth / layoutToPlotScale - x0;\r\n    let maxHeight = plotHeight / layoutToPlotScale - y0;\r\n    newWidth = Math.max(10 / layoutToPlotScale, Math.min(newWidth, maxWidth));\r\n    newHeight = Math.max(10 / layoutToPlotScale, Math.min(newHeight, maxHeight));\r\n\r\n    // Calculate new points for the rectangle\r\n    const newPoints = [\r\n      [x0, y0],\r\n      [x0 + newWidth, y0],\r\n      [x0 + newWidth, y0 + newHeight],\r\n      [x0, y0 + newHeight],\r\n    ];\r\n\r\n    // Reset the scale to 1\r\n    shape.scaleX(1);\r\n    shape.scaleY(1);\r\n\r\n    onUpdateRoom(idx, { ...layout[idx], points: newPoints });\r\n  };\r\n\r\n  if (validRooms.length === 0) {\r\n    return (\r\n      <div className=\"text-gray-400 text-lg\">\r\n        No valid rooms to display.\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <Stage width={width} height={height}>\r\n      <Layer>\r\n        {/* Plot area border */}\r\n        <Rect\r\n          x={offsetX}\r\n          y={offsetY}\r\n          width={plotWidth * scale}\r\n          height={plotHeight * scale}\r\n          stroke=\"#000\"\r\n          strokeWidth={2}\r\n          fill=\"transparent\"\r\n        />\r\n\r\n        {validRooms.map((room, idx) => {\r\n          // First, scale and center layout in plot space, then map plot to canvas\r\n          const scaledPoints = room.points.flatMap(([x, y]) => [\r\n            (x * layoutToPlotScale + layoutOffsetX) * scale + offsetX,\r\n            (y * layoutToPlotScale + layoutOffsetY) * scale + offsetY,\r\n          ]);\r\n          // Centroid for label\r\n          const [cx, cy] = getCentroid(\r\n            room.points.map(([x, y]) => [\r\n              (x * layoutToPlotScale + layoutOffsetX) * scale + offsetX,\r\n              (y * layoutToPlotScale + layoutOffsetY) * scale + offsetY,\r\n            ])\r\n          );\r\n          const isSelected = selectedRoom === idx;\r\n          const isHovered = hoveredIdx === idx;\r\n\r\n          // Find top-right corner for delete icon\r\n          const xs = scaledPoints.filter((_, i) => i % 2 === 0);\r\n          const ys = scaledPoints.filter((_, i) => i % 2 === 1);\r\n          const topRightX = Math.max(...xs);\r\n          const topRightY = Math.min(...ys);\r\n\r\n          return (\r\n            <Group\r\n              key={room.name + idx}\r\n              draggable\r\n              onDragEnd={e => handleDragEnd(idx, e)}\r\n              onMouseEnter={() => setHoveredIdx(idx)}\r\n              onMouseLeave={() => setHoveredIdx(null)}\r\n              onClick={() => onSelectRoom(idx)}\r\n              onTap={() => onSelectRoom(idx)}\r\n            >\r\n              <Line\r\n                ref={node => (shapeRefs.current[idx] = node)}\r\n                points={scaledPoints}\r\n                closed\r\n                fill=\"#e0e7ff\"\r\n                stroke={\r\n                  isSelected ? \"#f59e42\" : isHovered ? \"#2563eb\" : \"#1e293b\"\r\n                }\r\n                strokeWidth={isSelected ? 4 : isHovered ? 3 : 2}\r\n                shadowBlur={isSelected ? 8 : 0}\r\n              />\r\n              <Text\r\n                text={room.name}\r\n                x={cx}\r\n                y={cy}\r\n                fontSize={16}\r\n                fill=\"#1e293b\"\r\n                fontStyle=\"bold\"\r\n                align=\"center\"\r\n                verticalAlign=\"middle\"\r\n                offsetX={room.name.length * 8}\r\n                offsetY={8}\r\n              />\r\n\r\n              {/* Delete button/icon */}\r\n              {isSelected && onDeleteRoom && (\r\n                <>\r\n                  <Rect\r\n                    x={topRightX - 10}\r\n                    y={topRightY - 10}\r\n                    width={20}\r\n                    height={20}\r\n                    fill=\"#f87171\"\r\n                    cornerRadius={4}\r\n                    onClick={() => onDeleteRoom(idx)}\r\n                    onTap={() => onDeleteRoom(idx)}\r\n                    style={{ cursor: \"pointer\" }}\r\n                  />\r\n                  <Text\r\n                    text=\"🗑\"\r\n                    x={topRightX - 6}\r\n                    y={topRightY - 10}\r\n                    fontSize={16}\r\n                    onClick={() => onDeleteRoom(idx)}\r\n                    onTap={() => onDeleteRoom(idx)}\r\n                    style={{ cursor: \"pointer\" }}\r\n                  />\r\n                </>\r\n              )}\r\n              {/* Transformer for resizing rectangles */}\r\n              {isSelected && room.points.length === 4 && (\r\n                <Transformer\r\n                  ref={trRef}\r\n                  boundBoxFunc={(oldBox, newBox) => newBox}\r\n                  onTransformEnd={() => handleTransformEnd(idx)}\r\n                  rotateEnabled={false}\r\n                  enabledAnchors={[\r\n                    \"top-left\",\r\n                    \"top-right\",\r\n                    \"bottom-left\",\r\n                    \"bottom-right\",\r\n                  ]}\r\n                />\r\n              )}\r\n            </Group>\r\n          );\r\n        })}\r\n      </Layer>\r\n    </Stage>\r\n  );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}